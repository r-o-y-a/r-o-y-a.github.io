<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>8-Speaker Virtual Room</title>
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --accent:#88f;
    --muted:#94a3b8;
    --white:#e6eef6;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,var(--bg) 0%, #071025 100%);color:var(--white)}
  .app{
    display:grid;
    grid-template-columns:420px 1fr;
    gap:18px;
    padding:18px;
    height:100vh;
    box-sizing:border-box;
  }
  .panel{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:12px;
    padding:14px;
    box-shadow: 0 6px 30px rgba(2,6,23,0.6);
    border:1px solid rgba(255,255,255,0.03);
  }
  h1{margin:4px 0 10px;font-size:18px;color:var(--accent)}
  label{display:block;margin-top:8px;font-size:13px;color:var(--muted)}
  .files{display:grid;grid-template-columns:1fr 80px;gap:8px;align-items:center}
  input[type=file]{width:100%}
  button{
    margin-top:12px;padding:10px 12px;border-radius:8px;border:0;background:var(--accent);color:#072036;font-weight:600;cursor:pointer;
  }
  .row{display:flex;gap:8px;align-items:center}
  .small{font-size:13px;color:var(--muted)}
  canvas{width:100%;height:100%;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005)); display:block}
  .hud{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-top:8px}
  .control{display:flex;gap:8px;align-items:center}
  .slider{width:160px}
  .legend{display:flex;flex-wrap:wrap;gap:6px;margin-top:10px}
  .chip{padding:6px 8px;background:rgba(255,255,255,0.03);border-radius:999px;font-size:12px;color:var(--muted)}
  .footer{font-size:12px;color:var(--muted);margin-top:12px}
  .speaker-input{display:flex;gap:6px;align-items:center}
  .speaker-label{width:28px;text-align:center;font-weight:700}
  .tooltip{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div class="app">
  <div class="panel" id="controls">
    <h1>8-Speaker Virtual Room</h1>
    <div class="small">Load up to 8 WAV files (one per speaker). Use WASD / arrow keys to walk. Press <strong>Start Audio</strong> to enable playback.</div>

    <form id="filesForm" onsubmit="return false;">
      <div id="fileInputs">
        <!-- generated by JS -->
      </div>

      <label class="small" style="margin-top:10px">Room radius (meters)</label>
      <div class="row">
        <input id="roomRadius" type="range" min="3" max="40" value="18" class="slider">
        <div class="chip" id="roomRadiusVal">18 m</div>
      </div>

      <label class="small">Movement speed (m/s)</label>
      <div class="row">
        <input id="speed" type="range" min="0.5" max="8" value="3" step="0.1" class="slider">
        <div class="chip" id="speedVal">3.0</div>
      </div>

      <label class="small">Attenuation curve exponent</label>
      <div class="row">
        <input id="expo" type="range" min="0.5" max="5" value="2" step="0.1" class="slider">
        <div class="chip" id="expoVal">2.0</div>
      </div>

      <label class="small">Master volume</label>
      <div class="row">
        <input id="master" type="range" min="0" max="1" step="0.01" value="0.9" class="slider">
        <div class="chip" id="masterVal">0.90</div>
      </div>

      <div style="display:flex;gap:8px;margin-top:12px">
        <button id="startBtn" type="button">Start Audio & Enter Room</button>
        <button id="centerBtn" type="button">Center Listener</button>
      </div>

      <div class="legend">
        <div class="chip">WASD / ↑↓←→ to move</div>
        <div class="chip">Click canvas to teleport</div>
        <div class="chip">Files are played looped</div>
      </div>

      <div class="footer">Speakers placed evenly on room periphery. Volume increases as you approach.</div>
    </form>
  </div>

  <div class="panel" style="display:flex;flex-direction:column;gap:10px;padding:12px;">
    <canvas id="roomCanvas"></canvas>
    <div class="hud">
      <div class="control small"><span id="posLabel">x:0.0 y:0.0</span></div>
      <div class="control small"><span id="nearLabel">Nearest: —</span></div>
    </div>
  </div>
</div>

<script>
(() => {
  const NUM = 8;
  const container = document.getElementById('fileInputs');
  const startBtn = document.getElementById('startBtn');
  const centerBtn = document.getElementById('centerBtn');
  const roomRadiusInput = document.getElementById('roomRadius');
  const roomRadiusVal = document.getElementById('roomRadiusVal');
  const speedInput = document.getElementById('speed');
  const speedVal = document.getElementById('speedVal');
  const expoInput = document.getElementById('expo');
  const expoVal = document.getElementById('expoVal');
  const masterInput = document.getElementById('master');
  const masterVal = document.getElementById('masterVal');
  const posLabel = document.getElementById('posLabel');
  const nearLabel = document.getElementById('nearLabel');

  // Create inputs for 8 speakers
  for (let i=0;i<NUM;i++){
    const row = document.createElement('div');
    row.className = 'speaker-input';
    row.style.marginTop = '8px';
    const lbl = document.createElement('div');
    lbl.className = 'speaker-label';
    lbl.textContent = (i+1);
    const file = document.createElement('input');
    file.type = 'file';
    file.accept = 'audio/wav,audio/wave,audio/x-wav,audio/mpeg,audio/*';
    file.dataset.idx = i;
    const name = document.createElement('div');
    name.className = 'small';
    name.textContent = 'No file';
    name.style.flex = '1';
    file.addEventListener('change', (e)=> {
      const f = e.target.files[0];
      name.textContent = f ? f.name : 'No file';
      loadFileToSpeaker(f, Number(e.target.dataset.idx));
    });
    row.appendChild(lbl);
    row.appendChild(file);
    row.appendChild(name);
    container.appendChild(row);
  }

  // Audio state
  let audioCtx = null;
  let masterGain = null;
  let speakers = []; // {angle, x,y, buffer, source, gainNode, pannerNode, file}
  let started = false;

  const room = {
    radiusMeters: Number(roomRadiusInput.value),
    centerX: 0,
    centerY: 0
  };

  // listener position in meters (center is 0,0)
  let listener = {x:0, y:0};
  let keys = {};
  let lastTime = null;

  // Canvas setup
  const canvas = document.getElementById('roomCanvas');
  const ctx = canvas.getContext('2d', {alpha:false});
  function resizeCanvas(){
    canvas.width = canvas.clientWidth * devicePixelRatio;
    canvas.height = canvas.clientHeight * devicePixelRatio;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // Initialize speaker objects positioned evenly on circle
  function initSpeakers(){
    speakers = [];
    for (let i=0;i<NUM;i++){
      const angle = (i / NUM) * Math.PI * 2 - Math.PI/2; // start at top
      const x = Math.cos(angle) * room.radiusMeters;
      const y = Math.sin(angle) * room.radiusMeters;
      speakers.push({
        angle, x, y,
        buffer: null,
        source: null,
        gainNode: null,
        pannerNode: null,
        file: null,
        filename: null,
        color: `hsl(${(i/NUM)*360} 70% 60%)`
      });
    }
  }

  initSpeakers();

  // UI updates
  roomRadiusInput.addEventListener('input', ()=> {
    room.radiusMeters = Number(roomRadiusInput.value);
    roomRadiusVal.textContent = roomRadiusInput.value + ' m';
    initSpeakers();
  });
  speedInput.addEventListener('input', ()=> speedVal.textContent = Number(speedInput.value).toFixed(1));
  expoInput.addEventListener('input', ()=> expoVal.textContent = Number(expoInput.value).toFixed(1));
  masterInput.addEventListener('input', ()=> {
    masterVal.textContent = Number(masterInput.value).toFixed(2);
    if (masterGain) masterGain.gain.setValueAtTime(Number(masterInput.value), audioCtx.currentTime);
  });

  // Load local file and decode
  async function loadFileToSpeaker(file, idx){
    if (!file) return;
    speakers[idx].file = file;
    speakers[idx].filename = file.name;
    const arrayBuffer = await file.arrayBuffer();
    ensureAudioCtx();
    const buffer = await audioCtx.decodeAudioData(arrayBuffer);
    speakers[idx].buffer = buffer;
    if (started) createAndStartSource(idx);
  }

  // Ensure audio context exists (created on user gesture)
  function ensureAudioCtx(){
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = Number(masterInput.value);
    masterGain.connect(audioCtx.destination);
  }

  // Create and start buffer source for speaker
  function createAndStartSource(idx){
    const sp = speakers[idx];
    if (!sp.buffer) return;
    // Stop previous
    try{ if (sp.source) sp.source.stop(); } catch(e){}
    // nodes
    const src = audioCtx.createBufferSource();
    src.buffer = sp.buffer;
    src.loop = true;
    const gain = audioCtx.createGain();
    gain.gain.value = 0.0;
    const panner = audioCtx.createStereoPanner();
    // Connect: source -> gain -> panner -> master
    src.connect(gain);
    gain.connect(panner);
    panner.connect(masterGain);
    src.start(0);
    sp.source = src;
    sp.gainNode = gain;
    sp.pannerNode = panner;
  }

  // Start all loaded sources
  function startAllSources(){
    for (let i=0;i<NUM;i++){
      if (speakers[i].buffer && !speakers[i].source){
        createAndStartSource(i);
      }
    }
  }

  // Movement handling
  window.addEventListener('keydown', (e)=> { keys[e.key.toLowerCase()] = true; if (['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright'].includes(e.key.toLowerCase())) e.preventDefault(); });
  window.addEventListener('keyup', (e)=> { keys[e.key.toLowerCase()] = false; });

  // Click canvas to teleport listener
  canvas.addEventListener('click', (ev)=>{
    const rect = canvas.getBoundingClientRect();
    const cx = rect.left + rect.width/2;
    const cy = rect.top + rect.height/2;
    // convert click to meters relative to center
    const dx = (ev.clientX - cx) / Math.min(rect.width, rect.height) * room.radiusMeters * 2;
    const dy = (ev.clientY - cy) / Math.min(rect.width, rect.height) * room.radiusMeters * 2;
    // clamp inside circle
    const d = Math.hypot(dx, dy);
    if (d > room.radiusMeters){
      const scale = room.radiusMeters / d;
      listener.x = dx * scale;
      listener.y = dy * scale;
    } else {
      listener.x = dx; listener.y = dy;
    }
  });

  centerBtn.addEventListener('click', ()=> { listener.x = 0; listener.y = 0; });

  // Start button: resume audio context and start sources
  startBtn.addEventListener('click', async ()=>{
    ensureAudioCtx();
    await audioCtx.resume();
    started = true;
    startBtn.disabled = true;
    startAllSources();
    lastTime = performance.now();
    animate();
  });

  // Update audio per frame based on distance and angle
  function updateAudio(){
    if (!audioCtx) return;
    const expo = Number(expoInput.value);
    const maxD = room.radiusMeters;
    let nearest = {idx:-1, d:Infinity};
    for (let i=0;i<NUM;i++){
      const sp = speakers[i];
      const dx = sp.x - listener.x;
      const dy = sp.y - listener.y;
      const d = Math.hypot(dx, dy);
      if (d < nearest.d){ nearest = {idx:i, d}; }
      const norm = Math.min(d / maxD, 1);
      // attenuation: (1 - norm)^expo
      const gainVal = Math.max(0, Math.pow(1 - norm, expo));
      if (sp.gainNode) {
        // smooth ramp
        sp.gainNode.gain.cancelScheduledValues(audioCtx.currentTime);
        sp.gainNode.gain.linearRampToValueAtTime(gainVal, audioCtx.currentTime + 0.05);
      }
      // stereo pan from -1 (left) to +1 (right) by angle
      const angle = Math.atan2(dy, dx); // -pi..pi
      const pan = Math.sin(angle); // left/right mapping
      if (sp.pannerNode) sp.pannerNode.pan.setValueAtTime(pan, audioCtx.currentTime);
    }
    if (nearest.idx >= 0) nearLabel.textContent = `Nearest: ${nearest.idx+1} (${nearest.d.toFixed(2)} m)`;
    else nearLabel.textContent = 'Nearest: —';
  }

  // Render top-down room
  function render(){
    const dpr = devicePixelRatio || 1;
    const w = canvas.width;
    const h = canvas.height;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    // clear
    ctx.fillStyle = '#061025';
    ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);

    const cw = canvas.clientWidth;
    const ch = canvas.clientHeight;
    const cx = cw/2;
    const cy = ch/2;
    // map meters to pixels: radiusMeters -> min(cw,ch)*0.42
    const maxRadPx = Math.min(cw, ch) * 0.42;
    const metersToPx = (m) => (m / room.radiusMeters) * maxRadPx;

    // draw room circle
    ctx.beginPath();
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(136,128,255,0.18)';
    ctx.arc(cx, cy, maxRadPx, 0, Math.PI*2);
    ctx.stroke();

    // draw speakers
    for (let i=0;i<NUM;i++){
      const sp = speakers[i];
      const px = cx + metersToPx(sp.x);
      const py = cy + metersToPx(sp.y);
      // speaker body
      ctx.beginPath();
      ctx.fillStyle = sp.color;
      ctx.globalAlpha = 0.98;
      ctx.arc(px, py, 10, 0, Math.PI*2);
      ctx.fill();
      // inner dot
      ctx.beginPath();
      ctx.fillStyle = '#041224';
      ctx.arc(px, py, 4, 0, Math.PI*2);
      ctx.fill();
      // number
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.font = '11px system-ui, Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(String(i+1), px, py);
    }

    // draw listener
    const lp = {x: cx + metersToPx(listener.x), y: cy + metersToPx(listener.y)};
    ctx.beginPath();
    ctx.fillStyle = '#e6eef6';
    ctx.globalAlpha = 1.0;
    ctx.arc(lp.x, lp.y, 8, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // draw small orientation indicator (facing up)
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.arc(lp.x, lp.y-14, 3, 0, Math.PI*2);
    ctx.fill();

    // position label
    ctx.font = '12px system-ui, Arial';
    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    ctx.textAlign = 'left';
    ctx.fillText(`Listener: ${listener.x.toFixed(2)} m, ${listener.y.toFixed(2)} m`, 12, 18);

    // footer small legend
    ctx.globalAlpha = 1.0;
  }

  // Animation loop
  function animate(ts){
    const now = ts || performance.now();
    if (!lastTime) lastTime = now;
    const dt = Math.min(0.05, (now - lastTime) / 1000); // cap dt
    lastTime = now;

    // movement velocity
    const spd = Number(speedInput.value);
    let vx = 0, vy = 0;
    if (keys['w'] || keys['arrowup']) vy -= 1;
    if (keys['s'] || keys['arrowdown']) vy += 1;
    if (keys['a'] || keys['arrowleft']) vx -= 1;
    if (keys['d'] || keys['arrowright']) vx += 1;
    // normalize
    if (vx !== 0 || vy !== 0){
      const len = Math.hypot(vx, vy);
      vx /= len; vy /= len;
      listener.x += vx * spd * dt;
      listener.y += vy * spd * dt;
      // clamp inside room
      const dist = Math.hypot(listener.x, listener.y);
      if (dist > room.radiusMeters - 0.001){
        listener.x *= (room.radiusMeters - 0.001) / dist;
        listener.y *= (room.radiusMeters - 0.001) / dist;
      }
    }

    // update visuals and audio
    updateAudio();
    render();

    // UI text
    posLabel.textContent = `x:${listener.x.toFixed(2)} y:${listener.y.toFixed(2)}`;

    requestAnimationFrame(animate);
  }

  // helper to start auto-created silent sources if no file loaded (optional)
  // Not used; we require user to load files.

  // Expose a quick method to load sample oscillator for testing if needed (not automatically)
  window._debugCreateTestSound = async function(){
    ensureAudioCtx();
    for (let i=0;i<NUM;i++){
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      gain.gain.value = 0;
      const panner = audioCtx.createStereoPanner();
      osc.type = 'sine';
      osc.frequency.value = 110 + i*20;
      osc.connect(gain);
      gain.connect(panner);
      panner.connect(masterGain);
      osc.start();
      speakers[i].source = osc;
      speakers[i].gainNode = gain;
      speakers[i].pannerNode = panner;
    }
  };

  // initial render
  render();

})();
</script>
</body>
</html>