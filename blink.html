<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Blink Squares — robust loader</title>
<style>
  :root{--bg:#fbfbfb;--muted:#666;--card:#111}
  html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:#111}
  .wrap{min-height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;padding:20px;box-sizing:border-box}
  h1{margin:0;font-size:20px;font-weight:600}
  .squares{display:flex;gap:12px;align-items:center;justify-content:center}
  .sq{width:92px;height:92px;border-radius:12px;background:#111;display:flex;align-items:center;justify-content:center;color:white;font-weight:700;box-shadow:0 8px 20px rgba(12,12,12,.12);font-size:14px}
  .controls{display:flex;gap:12px;align-items:center;flex-wrap:wrap;justify-content:center}
  #startBtn{padding:12px 16px;font-size:16px;border-radius:10px;border:0;background:#111;color:#fff;cursor:pointer}
  #status{font-size:13px;color:var(--muted);max-width:720px;text-align:center}
  #errorBox{font-size:13px;color:#b00020;max-width:720px;text-align:left;white-space:pre-wrap}
  #videoEl{display:none;width:320px;height:240px}
  canvas{display:none}
  .note{font-size:13px;color:var(--muted);max-width:640px;text-align:center}
  .small{font-size:12px;color:var(--muted)}
  @media (max-width:420px){
    .sq{width:74px;height:74px;font-size:12px;border-radius:10px}
    #startBtn{font-size:15px;padding:10px 14px}
  }
  a.inline{color:inherit;text-decoration:underline}
</style>
</head>
<body>
<div class="wrap">
  <h1>Blink Squares — Left / Right / Both</h1>

  <div class="squares" aria-hidden="true">
    <div id="leftSq" class="sq" aria-label="left">LEFT</div>
    <div id="bothSq" class="sq" aria-label="both">BOTH</div>
    <div id="rightSq" class="sq" aria-label="right">RIGHT</div>
  </div>

  <div class="controls">
    <button id="startBtn" aria-label="Start camera" disabled>Start camera</button>
    <div id="status">Initializing libraries…</div>
  </div>

  <div id="errorBox" aria-live="polite"></div>

  <p class="note small">Runs in your browser (no uploads). If scripts fail to load, disable adblockers or ensure GitHub Pages serves the file over HTTPS. If you see a script load error below, follow the instructions shown.</p>

  <!-- Hidden video + canvas used by the detector -->
  <video id="videoEl" autoplay playsinline muted></video>
  <canvas id="hiddenCanvas"></canvas>
</div>

<script>
/* Robust single-file loader + blink detector.
   - Dynamically loads TF.js and face-landmarks (tries two CDNs)
   - Reports precise load errors and guidance
   - Then runs camera-first -> model -> detect loop
*/

const statusEl = document.getElementById('status');
const errorBox = document.getElementById('errorBox');
const startBtn = document.getElementById('startBtn');

function setStatus(txt){ statusEl.textContent = txt; }
function setError(txt){ errorBox.textContent = txt; console.warn(txt); }

// loadScript returns a Promise that resolves when script loads or rejects with error
function loadScript(url, opts = {}) {
  return new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = url;
    if(opts.crossorigin) s.crossOrigin = opts.crossorigin;
    s.async = true;
    s.onload = () => resolve(url);
    s.onerror = (e) => reject(new Error('Failed to load ' + url));
    document.head.appendChild(s);
  });
}

// try loading libraries in order with fallbacks
async function ensureLibraries() {
  // TF.js URLs
  const tfUrls = [
    'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js',
    'https://unpkg.com/@tensorflow/tfjs@3.21.0/dist/tf.min.js'
  ];
  // face-landmarks-detection UMD builds (global faceLandmarksDetection)
  const fldUrls = [
    'https://cdn.jsdelivr.net/npm/@tensorflow-models/face-landmarks-detection@1.0.3/dist/face-landmarks-detection.min.js',
    'https://unpkg.com/@tensorflow-models/face-landmarks-detection@1.0.3/dist/face-landmarks-detection.min.js'
  ];

  // Load TF.js first
  let tfLoaded = false;
  let tfErrs = [];
  for(const u of tfUrls){
    try{
      setStatus(`Loading TensorFlow (from ${new URL(u).hostname})…`);
      await loadScript(u);
      if(window.tf) { tfLoaded = true; break; }
      // sometimes script loads but global not set; treat as error
      tfErrs.push(`Loaded ${u} but window.tf not found`);
    } catch(err){
      tfErrs.push(err.message || String(err));
    }
  }
  if(!tfLoaded){
    setError('TensorFlow failed to load.\nTried:\n' + tfErrs.join('\n') + '\n\nFixes: disable adblocker, ensure network allows CDN, or host the scripts locally.');
    throw new Error('tf load failed');
  }

  // Load face-landmarks-detection
  let fldLoaded = false;
  let fldErrs = [];
  for(const u of fldUrls){
    try{
      setStatus(`Loading face-landmarks model library (from ${new URL(u).hostname})…`);
      await loadScript(u);
      // check global
      if(window.faceLandmarksDetection || window.faceLandmarksDetection !== undefined){
        fldLoaded = true;
        break;
      }
      fldErrs.push(`Loaded ${u} but faceLandmarksDetection not found`);
    } catch(err){
      fldErrs.push(err.message || String(err));
    }
  }
  if(!fldLoaded){
    setError('face-landmarks-detection library failed to load.\nTried:\n' + fldErrs.join('\n') + '\n\nFixes: disable adblocker/Script blockers, ensure HTTPS, or use a different browser.');
    throw new Error('face-landmarks load failed');
  }

  // libraries present — enable start button
  setStatus('Libraries loaded. Press Start to enable camera.');
  startBtn.disabled = false;
  return true;
}

// Kick off library loading immediately
ensureLibraries().catch(err => {
  console.error('Library init failed', err);
});

// ---- Blink detection logic (same as before) ----
const videoEl = document.getElementById('videoEl');
const canvas = document.getElementById('hiddenCanvas');
const leftSq = document.getElementById('leftSq');
const rightSq = document.getElementById('rightSq');
const bothSq = document.getElementById('bothSq');

const COLORS = { none:'#111', left:'#ff6b6b', right:'#63c2ff', both:'#ffd36b' };
function showEvent(ev){
  leftSq.style.background = ev === 'left' ? COLORS.left : COLORS.none;
  rightSq.style.background = ev === 'right' ? COLORS.right : COLORS.none;
  bothSq.style.background = ev === 'both' ? COLORS.both : COLORS.none;
}
showEvent('none');

let EAR_THRESHOLD = 0.24;
const WIDTH_IDEAL = 640, HEIGHT_IDEAL = 480;
let model = null;
let running = false;
let closingLeft = false, closingRight = false;
let lastEvent = 'none';

// bbox helper
function bbox(points){
  const xs = points.map(p=>p[0]), ys = points.map(p=>p[1]);
  return {minX:Math.min(...xs), maxX:Math.max(...xs), minY:Math.min(...ys), maxY:Math.max(...ys)};
}

function showErrorMessage(msg, err){
  setError(msg + (err ? '\n' + (err.name ? (err.name + ': ' + err.message) : String(err)) : ''));
}

async function startCameraWithFallback(){
  errorBox.textContent = '';
  setStatus('Requesting camera (tap allow)…');
  startBtn.disabled = true;
  const tryConstraints = [
    { video: { facingMode: 'user', width: { ideal: WIDTH_IDEAL }, height: { ideal: HEIGHT_IDEAL } }, audio: false },
    { video: { facingMode: 'user' }, audio: false },
    { video: true, audio: false }
  ];
  for(const c of tryConstraints){
    try{
      const stream = await navigator.mediaDevices.getUserMedia(c);
      videoEl.srcObject = stream;
      await new Promise(r => videoEl.onloadedmetadata = r);
      canvas.width = videoEl.videoWidth || WIDTH_IDEAL;
      canvas.height = videoEl.videoHeight || HEIGHT_IDEAL;
      setStatus('Camera started');
      return stream;
    } catch(err){
      console.warn('getUserMedia error for', c, err);
      if(err.name === 'NotAllowedError' || err.name === 'SecurityError'){
        showErrorMessage('Camera permission denied. To enable: in Safari tap aA → Website Settings → Camera → Allow, or go to iOS Settings → Safari → Camera.');
        startBtn.disabled = false;
        return null;
      } else if(err.name === 'OverconstrainedError' || err.name === 'ConstraintNotSatisfiedError'){
        setStatus('Device constraints not supported — trying fallback …');
        continue;
      } else if(err.name === 'NotReadableError' || err.name === 'TrackStartError'){
        showErrorMessage('Camera is busy or unavailable. Close other apps/tabs and try again.', err);
        startBtn.disabled = false;
        return null;
      } else {
        showErrorMessage('Unable to start camera. See console for details.', err);
        startBtn.disabled = false;
        return null;
      }
    }
  }
  showErrorMessage('Unable to access camera with any constraint set.');
  startBtn.disabled = false;
  return null;
}

async function loadModelAfterCamera(){
  try{
    setStatus('Loading face-landmarks model (MediaPipe facemesh)…');
    // faceLandmarksDetection global should be present after our loader
    if(!window.faceLandmarksDetection){
      throw new Error('faceLandmarksDetection not found on window');
    }
    model = await window.faceLandmarksDetection.load(window.faceLandmarksDetection.SupportedPackages.mediapipeFacemesh);
    setStatus('Model loaded — detecting blinks/winks');
    return true;
  } catch(err){
    showErrorMessage('Model failed to load. Check network or try again.', err);
    return false;
  }
}

async function detectLoop(){
  running = true;
  while(running){
    try{
      const faces = await model.estimateFaces({ input: videoEl, returnTensors: false, flipHorizontal: true });
      if(faces && faces.length){
        const f = faces[0];
        const leftEye = (f.annotations.leftEyeUpper0 || []).concat(f.annotations.leftEyeLower0 || []);
        const rightEye = (f.annotations.rightEyeUpper0 || []).concat(f.annotations.rightEyeLower0 || []);
        if(leftEye.length && rightEye.length){
          const L = bbox(leftEye), R = bbox(rightEye);
          const leftEAR = (L.maxY - L.minY) / (L.maxX - L.minX + 1e-6);
          const rightEAR = (R.maxY - R.minY) / (R.maxX - R.minX + 1e-6);
          const leftClosed = leftEAR < EAR_THRESHOLD;
          const rightClosed = rightEAR < EAR_THRESHOLD;

          if(leftClosed) closingLeft = true;
          if(rightClosed) closingRight = true;

          if(!leftClosed && !rightClosed && (closingLeft || closingRight)){
            if(closingLeft && closingRight){
              lastEvent = 'both';
            } else if(closingLeft){
              lastEvent = 'left';
            } else if(closingRight){
              lastEvent = 'right';
            } else {
              lastEvent = 'both';
            }
            showEvent(lastEvent);
            setStatus(`Detected: ${lastEvent.toUpperCase()}`);
            closingLeft = closingRight = false;
          }
        }
      } else {
        setStatus('No face detected — please face the camera');
      }
    } catch(err){
      console.error('Detection error', err);
      showErrorMessage('Detection error (see console).', err);
    }
    await new Promise(r => requestAnimationFrame(r));
  }
}

// Start button: camera then model then loop
startBtn.addEventListener('click', async () => {
  errorBox.textContent = '';
  setStatus('Starting… (camera -> model)');
  startBtn.disabled = true;
  const stream = await startCameraWithFallback();
  if(!stream) return;
  const ok = await loadModelAfterCamera();
  if(!ok) return;
  detectLoop();
});

// helpful note if scripts blocked
(function showBlockingAdviceSoon(){
  setTimeout(()=>{
    // if after 6s no start enabled, show likely block reason
    if(startBtn.disabled && startBtn.textContent.includes('Start')) {
      // if libraries haven't enabled the start button then we likely failed loading scripts
      // but ensure user sees errorBox content (populated earlier)
      if(!errorBox.textContent) {
        setError('If Start stays disabled for long: the script files may be blocked by an extension or network. Try disabling ad/script blockers or use a different browser. See console for details.');
      }
    }
  }, 6000);
})();
</script>
</body>
</html>