<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Blink Squares — Local TFJS runtime (blink.html)</title>
<style>
  :root{--bg:#fbfbfb;--muted:#666}
  
html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe 
UI,Roboto,Helvetica,Arial;color:#111}
  
.wrap{min-height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:12px;padding:20px;box-sizing:border-box}
  h1{margin:0;font-size:20px;font-weight:600}
  .squares{display:flex;gap:12px;align-items:center;justify-content:center}
  
.sq{width:92px;height:92px;border-radius:12px;background:#111;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700;box-shadow:0 
8px 20px rgba(12,12,12,.12);font-size:14px}
  .controls{display:flex;gap:12px;align-items:center;flex-wrap:wrap;justify-content:center}
  #startBtn{padding:12px 
18px;font-size:16px;border-radius:10px;border:0;background:#111;color:#fff;cursor:pointer}
  #status{font-size:13px;color:var(--muted);max-width:720px;text-align:center}
  
#errorBox{font-size:13px;color:#b00020;max-width:720px;text-align:left;white-space:pre-wrap}
  #videoEl{display:none}
  canvas{display:none}
  .note{font-size:13px;color:var(--muted);max-width:640px;text-align:center}
  @media (max-width:420px){ .sq{width:74px;height:74px;font-size:12px} 
#startBtn{font-size:15px} }
  
#debugLog{font-family:monospace;font-size:12px;color:#222;max-width:720px;white-space:pre-wrap;text-align:left}
</style>
</head>
<body>
<div class="wrap">
  <h1>Blink Squares — Left / Right / Both</h1>

  <div class="squares" aria-hidden="true">
    <div id="leftSq" class="sq" aria-label="left">LEFT</div>
    <div id="bothSq" class="sq" aria-label="both">BOTH</div>
    <div id="rightSq" class="sq" aria-label="right">RIGHT</div>
  </div>

  <div class="controls">
    <button id="startBtn">Start camera</button>
    <div id="status">Click Start. This uses local files: <code>libs/tf.min.js</code> and 
<code>libs/face-landmarks-detection.min.js</code>.</div>
  </div>

  <div id="errorBox" aria-live="polite"></div>
  <pre id="debugLog"></pre>

  <p class="note">Place local libs at the repo paths: <code>libs/tf.min.js</code> and 
<code>libs/face-landmarks-detection.min.js</code>. No mediapipe files required for this 
build.</p>

  <video id="videoEl" autoplay playsinline muted></video>
  <canvas id="hiddenCanvas"></canvas>
</div>

<!-- Local libs must exist in these paths -->
<script src="libs/tf.min.js"></script>
<script src="libs/face-landmarks-detection.min.js"></script>

<script>
/* blink.html — TFJS runtime version.
   REQUIRED local files:
     libs/tf.min.js
     libs/face-landmarks-detection.min.js
   This uses the TFJS backend (no mediapipe wasm required).
*/

const startBtn = document.getElementById('startBtn');
const statusEl = document.getElementById('status');
const errorBox = document.getElementById('errorBox');
const debugLog = document.getElementById('debugLog');
const leftSq = document.getElementById('leftSq');
const rightSq = document.getElementById('rightSq');
const bothSq = document.getElementById('bothSq');
const videoEl = document.getElementById('videoEl');
const canvas = document.getElementById('hiddenCanvas');

function log(...args){ debugLog.textContent += args.map(a => (typeof a === 'object' ? 
JSON.stringify(a) : String(a))).join(' ') + '\n'; console.log(...args); }
function setStatus(s){ statusEl.textContent = s; log('[STATUS]', s); }
function setError(s){ errorBox.textContent = s; log('[ERROR]', s); }

function showEvent(ev){
  const COLORS = { none:'#111', left:'#ff6b6b', right:'#63c2ff', both:'#ffd36b' };
  leftSq.style.background = ev === 'left' ? COLORS.left : COLORS.none;
  rightSq.style.background = ev === 'right' ? COLORS.right : COLORS.none;
  bothSq.style.background = ev === 'both' ? COLORS.both : COLORS.none;
}
showEvent('none');

// Defensive presence checks
if(!window.tf){
  setError('Missing local file: libs/tf.min.js (window.tf not found). Place TensorFlow JS at 
libs/tf.min.js');
}
if(!window.faceLandmarksDetection){
  setError('Missing local file: libs/face-landmarks-detection.min.js 
(window.faceLandmarksDetection not found). Place the face-landmarks-detection UMD at 
libs/face-landmarks-detection.min.js');
}

// state
let model = null;
let running = false;
let closingLeft = false, closingRight = false;
let EAR_THRESHOLD = 0.24;

function bbox(points){ const xs = points.map(p=>p[0]), ys = points.map(p=>p[1]); return 
{minX:Math.min(...xs), maxX:Math.max(...xs), minY:Math.min(...ys), maxY:Math.max(...ys)}; }

async function requestCamera(){
  setError(''); setStatus('Requesting camera (user gesture)…');
  try{
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', 
width: { ideal: 640 }, height: { ideal: 480 } }, audio: false });
    videoEl.srcObject = stream;
    await new Promise(r => videoEl.onloadedmetadata = r);
    canvas.width = videoEl.videoWidth || 640;
    canvas.height = videoEl.videoHeight || 480;
    setStatus('Camera started');
    return stream;
  } catch(err){
    setError('Camera error: ' + (err && err.name ? err.name + ' — ' + err.message : 
String(err)));
    throw err;
  }
}

async function loadModelTFJS(){
  setStatus('Loading face-landmarks model (TFJS runtime)…');
  try{
    // Use TFJS runtime. SupportedPackages.mediapipeFacemesh works when runtime:'tfjs'
    model = await 
faceLandmarksDetection.load(faceLandmarksDetection.SupportedPackages.mediapipeFacemesh, {
      runtime: 'tfjs'
    });
    setStatus('Model loaded (TFJS) — detecting blinks/winks');
    return true;
  } catch(err){
    setError('Model load failed (TFJS runtime). Error: ' + (err && err.message ? err.message 
: String(err)));
    console.error(err);
    throw err;
  }
}

async function detectLoop(){
  running = true;
  setStatus('Detecting — blink/wink will light the squares');
  while(running){
    try{
      const faces = await model.estimateFaces({ input: videoEl, returnTensors: false, 
flipHorizontal: true });
      if(faces && faces.length){
        const f = faces[0];
        const leftEye = (f.annotations.leftEyeUpper0 || 
[]).concat(f.annotations.leftEyeLower0 || []);
        const rightEye = (f.annotations.rightEyeUpper0 || 
[]).concat(f.annotations.rightEyeLower0 || []);
        if(leftEye.length && rightEye.length){
          const L = bbox(leftEye), R = bbox(rightEye);
          const leftEAR = (L.maxY - L.minY) / (L.maxX - L.minX + 1e-6);
          const rightEAR = (R.maxY - R.minY) / (R.maxX - R.minX + 1e-6);
          const leftClosed = leftEAR < EAR_THRESHOLD;
          const rightClosed = rightEAR < EAR_THRESHOLD;
          if(leftClosed) closingLeft = true;
          if(rightClosed) closingRight = true;
          if(!leftClosed && !rightClosed && (closingLeft || closingRight)){
            let ev = 'both';
            if(closingLeft && !closingRight) ev = 'left';
            else if(closingRight && !closingLeft) ev = 'right';
            showEvent(ev);
            setStatus('Detected: ' + ev.toUpperCase());
            closingLeft = closingRight = false;
          }
        }
      } else {
        setStatus('No face detected — please face the camera');
      }
    } catch(err){
      console.error('Detection error', err);
      setError('Detection error: ' + (err && err.message ? err.message : String(err)));
      // continue loop
    }
    await new Promise(r => requestAnimationFrame(r));
  }
}

// Main start handler
startBtn.addEventListener('click', async () => {
  // quick guard if missing libs
  if(!window.tf || !window.faceLandmarksDetection){
    setError('Missing required local libs. See top of page. Aborting start.');
    return;
  }
  startBtn.disabled = true;
  debugLog.textContent = '';
  try{
    await requestCamera();
  } catch(e){
    startBtn.disabled = false;
    return;
  }
  try{
    await loadModelTFJS();
  } catch(e){
    startBtn.disabled = false;
    return;
  }
  detectLoop();
});

// Expose small helpers in console
window._blinkDemo = {
  stop: () => { running = false; setStatus('Stopped'); },
  setEAR: v => { EAR_THRESHOLD = Number(v); log('[DEBUG] EAR set to', EAR_THRESHOLD); }
};
</script>
</body>
</html>
