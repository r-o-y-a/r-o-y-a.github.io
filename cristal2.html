<script>
const SMOOTH_ALPHA = 0.18,
      MAX_ACCEL = 25,          // pixels/frame^2 threshold for "jerkiness"
      MAX_VELOCITY = 35,       // pixels/frame threshold for brightness
      PRESSURE_SENSITIVITY = 1.2,
      STUTTER_RATE_MIN = 6,
      STUTTER_RATE_MAX = 22,
      STUTTER_DUTY = 0.5;

let audioCtx=null, buffer=null, src=null,
    distortion=null, filter=null, chopGain=null, masterGain=null,
    stutterTimer=null,
    active=false, lastY=null, lastVelocity=0,
    velocity=0, acceleration=0, pressure=0,
    glitching=false;

const rod=document.getElementById('rod'),
      fileInput=document.getElementById('fileInput'),
      fileLabel=document.getElementById('fileLabel'),
      instr=document.getElementById('instr'),
      canvas=document.getElementById('particles'),
      ctx=canvas.getContext('2d');

let particles=[];

/* ---------- PARTICLES ---------- */
function resizeCanvas(){canvas.width=window.innerWidth;canvas.height=window.innerHeight;}
window.addEventListener('resize',resizeCanvas);resizeCanvas();

function spawnParticles(y, accel, press){
  const accelNorm = Math.min(1, Math.abs(accel)/MAX_ACCEL);
  const hue = (1 - accelNorm)*200 + accelNorm*0; // blueâ†’red
  const color = `hsl(${hue},100%,60%)`;
  const count = Math.ceil(2 + 6*accelNorm + 3*press);
  const rodRect = rod.getBoundingClientRect();
  for(let i=0;i<count;i++){
    particles.push({
      x: rodRect.left + rodRect.width/2 + (Math.random()-0.5)*4,
      y: y + (Math.random()-0.5)*8,
      vx: (Math.random()-0.5)*(1+3*accelNorm),
      vy: (Math.random()-0.5)*(2+5*accelNorm),
      life: 1,
      color
    });
  }
}
function updateParticles(dt){
  particles = particles.filter(p=>p.life>0);
  for(let p of particles){
    p.x += p.vx*dt*60;
    p.y += p.vy*dt*60;
    p.life -= dt*1.2;
  }
}
function drawParticles(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  for(let p of particles){
    ctx.globalAlpha = Math.max(0,p.life);
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x,p.y,2,2);
  }
  ctx.globalAlpha = 1;
}
let lastT=performance.now();
function animate(t){
  const dt=(t-lastT)/1000;
  lastT=t;
  updateParticles(dt);
  drawParticles();
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);
/* -------------------------------- */

function ensureAudioCtx(){
  if(!audioCtx)
    audioCtx=new(window.AudioContext||window.webkitAudioContext)();
}

async function loadFile(file){
  ensureAudioCtx();
  const ab=await file.arrayBuffer();
  buffer=await audioCtx.decodeAudioData(ab);
  fileLabel.textContent=file.name;
}

function makeDistortion(amount=0){
  const ws=audioCtx.createWaveShaper();
  const k=Math.max(0,Math.min(1000,amount*400));
  const n=2048, curve=new Float32Array(n);
  for(let i=0;i<n;i++){
    const x=(i/(n-1))*2-1;
    curve[i]=(1+k)*x/(1+k*Math.abs(x));
  }
  ws.curve=curve; ws.oversample='2x';
  return ws;
}

function startPlayback(){
  if(!audioCtx||!buffer)return;
  distortion=makeDistortion(0);
  filter=audioCtx.createBiquadFilter(); filter.type='lowpass'; filter.frequency.value=12000; filter.Q.value=0.7;
  chopGain=audioCtx.createGain(); chopGain.gain.value=1;
  masterGain=audioCtx.createGain(); masterGain.gain.value=0.9;
  src=audioCtx.createBufferSource(); src.buffer=buffer; src.loop=true;
  src.connect(distortion); distortion.connect(filter); filter.connect(chopGain); chopGain.connect(masterGain); masterGain.connect(audioCtx.destination);
  src.start();
  rod.classList.add('playing');
}
function stopPlayback(){
  try{ if(src){src.stop(0);src.disconnect();}}catch(e){}
  src=null;
  clearStutter();
  glitching=false; lastY=null; lastVelocity=0;
  rod.classList.remove('playing'); rod.classList.remove('glitch');
}

function startStutter(rateHz){
  clearStutter();
  if(!chopGain)return;
  const periodMs = 1000 / rateHz;
  let on = true;
  stutterTimer = setInterval(()=>{
    on=!on;
    chopGain.gain.setValueAtTime(on?1:0,audioCtx.currentTime);
  }, periodMs * STUTTER_DUTY);
}
function clearStutter(){
  if(stutterTimer){clearInterval(stutterTimer);stutterTimer=null;}
  if(chopGain)chopGain.gain.setValueAtTime(1,audioCtx?audioCtx.currentTime:0);
}

/* --- gesture mapping --- */
function mapToSpectralParams(velocity, acceleration, pressure){
  const velNorm = Math.min(1, Math.abs(velocity)/MAX_VELOCITY);
  const accNorm = Math.min(1, Math.abs(acceleration)/MAX_ACCEL);
  const brightness = 2000 + velNorm * 10000;
  const distortionAmt = accNorm;
  const stutterRate = STUTTER_RATE_MIN + accNorm*(STUTTER_RATE_MAX-STUTTER_RATE_MIN);
  const amp = 0.4 + pressure * PRESSURE_SENSITIVITY;
  return {brightness, distortionAmt, stutterRate, amp};
}

/* --- interaction --- */
function onPointerDown(e){
  e.preventDefault();
  ensureAudioCtx();
  if(audioCtx.state==='suspended')audioCtx.resume();
  if(!buffer){instr.textContent='Please upload a WAV first.';return;}
  active=true;
  const t=e.touches?e.touches[0]:e;
  lastY=t.clientY;
  lastVelocity=0;
  pressure=t.force||0.5;
  startPlayback();
}

function onPointerMove(e){
  if(!active)return;
  const t=e.touches?e.touches[0]:e;
  const y=t.clientY;
  const f=t.force||0.5;
  velocity = y - lastY;
  acceleration = velocity - lastVelocity;
  pressure = f;

  const p = mapToSpectralParams(velocity, acceleration, pressure);

  /* spectral control mapping */
  if(filter) filter.frequency.setTargetAtTime(p.brightness*(1-pressure*0.3), audioCtx.currentTime, 0.05);
  if(distortion) distortion.curve = makeDistortion(p.distortionAmt).curve;
  if(masterGain) masterGain.gain.setTargetAtTime(p.amp, audioCtx.currentTime, 0.05);
  if(Math.abs(acceleration) > 3) spawnParticles(y, acceleration, pressure);

  /* stutter activation */
  if(Math.abs(acceleration) > 5 && !glitching){
    glitching = true; rod.classList.add('glitch');
    startStutter(p.stutterRate);
  } else if(Math.abs(acceleration) < 2 && glitching){
    glitching = false; rod.classList.remove('glitch');
    clearStutter();
  }

  lastVelocity = velocity;
  lastY = y;
}

function onPointerUp(e){
  active=false;
  stopPlayback();
}

/* --- file + drag --- */
fileInput.addEventListener('change', async(ev)=>{
  if(ev.target.files && ev.target.files[0]) await loadFile(ev.target.files[0]);
});
rod.addEventListener('dragover', e=>{e.preventDefault();rod.style.opacity=0.9;});
rod.addEventListener('dragleave', ()=>rod.style.opacity='');
rod.addEventListener('drop', async e=>{
  e.preventDefault(); rod.style.opacity='';
  const f=e.dataTransfer.files[0];
  if(f) await loadFile(f);
});

/* --- event listeners --- */
rod.addEventListener('touchstart', onPointerDown, {passive:false});
window.addEventListener('touchmove', onPointerMove, {passive:false});
window.addEventListener('touchend', onPointerUp, {passive:false});
window.addEventListener('touchcancel', onPointerUp, {passive:false});
rod.addEventListener('pointerdown', onPointerDown);
window.addEventListener('pointermove', onPointerMove);
window.addEventListener('pointerup', onPointerUp);

document.getElementById('btn').addEventListener('click', ()=>fileInput.click());
document.addEventListener('visibilitychange', ()=>{if(document.hidden&&active)onPointerUp();});
</script>