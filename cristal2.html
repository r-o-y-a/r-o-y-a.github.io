<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Cristal Rod â€” Realistic Spectrogram</title>
<style>
  :root{--bg:#0b0b0c;--rod-glow:#9fe1ff;--text:#e6eef6}
  html,body,*{user-select:none;-webkit-user-select:none;-webkit-touch-callout:none;-webkit-user-drag:none}
  html,body{height:100%;margin:0;background:var(--bg);overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto}
  .instructions{position:fixed;top:6px;left:6px;right:6px;z-index:50;color:var(--text);font-size:14px;text-align:center;pointer-events:none}
  #uploadBtn{position:fixed;top:6px;right:6px;z-index:60;text-align:right}
  #fileLabel{font-size:12px;color:#cfe9ff;margin-top:6px}
  input[type=file]{display:none}
  label.upload-label{display:inline-block;padding:6px 12px;background:#1b1b1d;color:#e6eef6;border:1px solid #555;border-radius:4px;cursor:pointer;font-size:14px}
  label.upload-label:hover{background:#2b2b2f}
  .stage{width:100%;height:100%;display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden}
  .rod{width:8mm;height:100vh;border-radius:6px;background:linear-gradient(180deg,rgba(255,255,255,0.08),rgba(255,255,255,0.02));
        box-shadow:0 8px 30px rgba(0,0,0,0.6),inset 0 0 18px rgba(255,255,255,0.02);
        display:flex;align-items:center;justify-content:center;
        transition:box-shadow 120ms,transform 120ms;-webkit-tap-highlight-color:transparent;pointer-events:auto;touch-action:none;position:relative;z-index:10}
  .rod.playing{box-shadow:0 10px 40px rgba(0,0,0,0.7),0 0 28px var(--rod-glow),inset 0 0 22px rgba(255,255,255,0.05);transform:scale(1.01)}
  .rod.glitch{box-shadow:0 10px 40px rgba(0,0,0,0.7),0 0 40px #ff9fa0,inset 0 0 22px rgba(255,255,255,0.05);transform:scale(1.03) rotate(-0.2deg)}
  .hairline{width:60%;height:2px;background:linear-gradient(90deg,transparent,rgba(255,255,255,0.12),transparent);border-radius:2px;opacity:0.9}
  canvas#particles{position:absolute;top:0;left:0;width:100%;height:100%;z-index:1;pointer-events:none}
  canvas#spec{position:fixed;right:8px;top:50%;transform:translateY(-50%);width:220px;height:360px;border:1px solid rgba(255,255,255,0.04);z-index:40;background:rgba(0,0,0,0.06)}
</style>
</head>
<body>
<div class="instructions" id="instr">Upload a WAV, then touch the rod to play. Spectrogram shows a realistic glass response (pre-distortion).</div>

<div id="uploadBtn">
  <label class="upload-label">
    <input id="fileInput" type="file" accept=".wav,audio/*">
    <span>Upload WAV</span>
  </label>
  <div id="fileLabel"></div>
</div>

<div class="stage">
  <canvas id="particles"></canvas>
  <div id="rod" class="rod" role="button"><div class="hairline"></div></div>
</div>

<canvas id="spec" width="220" height="360"></canvas>

<script>
/* config */
const MAX_ACCEL = 60;
const MAX_VELOCITY = 70;
const PRESSURE_SENSITIVITY = 1.2;

/* cristal base for modal placement */
const CRISTAL_BASE = 146.83; // D3

let audioCtx=null, buffer=null, src=null,
    distortion=null, filter=null, masterGain=null,
    analyser=null, analyserFftSize=4096,
    // pre-distortion modal branch
    modalFilters=[], modalGains=[], preAnalyser=null, preSum=null,
    active=false, lastY=null, lastVelocity=0,
    velocity=0, acceleration=0, pressure=0,
    glitching=false;

const PARTIALS = 12; // number of resonant modes to simulate

const rod=document.getElementById('rod'),
      fileInput=document.getElementById('fileInput'),
      fileLabel=document.getElementById('fileLabel'),
      instr=document.getElementById('instr'),
      canvas=document.getElementById('particles'),
      ctx=canvas.getContext('2d'),
      specCanvas=document.getElementById('spec'),
      sctx=specCanvas.getContext('2d');

let particles=[]; function resizeCanvas(){canvas.width=window.innerWidth;canvas.height=window.innerHeight;}
window.addEventListener('resize',resizeCanvas);resizeCanvas();

/* spawn visuals */
function spawnParticles(y,accel,press){
  const accelNorm=Math.min(1,Math.abs(accel)/MAX_ACCEL);
  const hue=(1-accelNorm)*200+accelNorm*0;
  const color=`hsl(${hue},100%,60%)`;
  const count=Math.ceil(1+3*accelNorm+2*press);
  const rodRect=rod.getBoundingClientRect();
  for(let i=0;i<count;i++) particles.push({
    x:rodRect.left+rodRect.width/2+(Math.random()-0.5)*4,
    y:y+(Math.random()-0.5)*8,
    vx:(Math.random()-0.5)*(1+2*accelNorm),
    vy:(Math.random()-0.5)*(1+3*accelNorm),
    life:1,color
  });
}
function updateParticles(dt){ particles=particles.filter(p=>p.life>0); for(let p of particles){ p.x+=p.vx*dt*60; p.y+=p.vy*dt*60; p.life-=dt*0.9; } }
function drawParticles(){ ctx.clearRect(0,0,canvas.width,canvas.height); for(let p of particles){ ctx.globalAlpha=Math.max(0,p.life); ctx.fillStyle=p.color; ctx.fillRect(p.x,p.y,2,2);} ctx.globalAlpha=1; }
let lastT=performance.now();

/* spectrogram drawing */
sctx.fillStyle='black'; sctx.fillRect(0,0,specCanvas.width,specCanvas.height);
function drawSpectrogram(freqData){
  sctx.drawImage(specCanvas, -1, 0);
  const w = specCanvas.width, h = specCanvas.height, bins = freqData.length;
  for (let i = 0; i < bins; i++){
    const mag = freqData[i], y = Math.floor(h - (i / bins) * h), brightness = mag / 255;
    const hue = (1 - brightness) * 220;
    sctx.fillStyle = `hsl(${hue},80%,${20 + brightness*60}%)`;
    sctx.fillRect(w-1, y, 1, Math.ceil(h / bins + 0.5));
  }
}

/* audio helpers */
function ensureAudioCtx(){ if(!audioCtx) audioCtx=new(window.AudioContext||window.webkitAudioContext)(); }

async function loadFile(file){ ensureAudioCtx(); const ab=await file.arrayBuffer(); buffer=await audioCtx.decodeAudioData(ab); fileLabel.textContent=file.name; }

/* classic waveshaper */
function makeDistortion(amount=0){
  const ws=audioCtx.createWaveShaper();
  const k=Math.max(0,Math.min(1000,amount*300));
  const n=2048,curve=new Float32Array(n);
  for(let i=0;i<n;i++){ const x=(i/(n-1))*2-1; curve[i]=(1+k)*x/(1+k*Math.abs(x)); }
  ws.curve=curve; ws.oversample='2x'; return ws;
}

/* build modal filter bank (pre-distortion) */
function buildModalBank(){
  modalFilters=[]; modalGains=[];
  // create a master summing gain node for modal outputs
  preSum = audioCtx.createGain(); preSum.gain.value = 1;
  // slight inharmonicity curve to mimic glass rods
  for(let i=1;i<=PARTIALS;i++){
    // base harmonic with small positive inharmonicity increasing with mode number
    const inharm = 1 + 0.0025 * i; // tweakable
    const center = CRISTAL_BASE * i * inharm;
    const b = audioCtx.createBiquadFilter();
    b.type = 'bandpass';
    b.frequency.value = center;
    // higher modes are broader (lower Q)
    const Q = Math.max(6, 30 - i*1.8);
    b.Q.value = Q;
    const g = audioCtx.createGain(); g.gain.value = 0.0; // start quiet
    // connect: src -> b -> g -> preSum
    modalFilters.push(b); modalGains.push(g);
    b.connect(g); g.connect(preSum);
  }
  // analyser to visualize modal sum
  preAnalyser = audioCtx.createAnalyser();
  preAnalyser.fftSize = 4096;
  preAnalyser.smoothingTimeConstant = 0.08; // responsive but smooth
  preSum.connect(preAnalyser);
  // do NOT connect preSum to destination
}

/* start/stop playback: main audio unchanged, but also set up modal branch */
function startPlayback(){
  if(!audioCtx||!buffer)return;
  stopPlayback();
  // main audio chain (with distortion) - unchanged
  distortion = makeDistortion(0);
  filter = audioCtx.createBiquadFilter(); filter.type='lowpass'; filter.frequency.value=12000; filter.Q.value=0.7;
  masterGain = audioCtx.createGain(); masterGain.gain.value=0.9;
  analyser = audioCtx.createAnalyser(); analyser.fftSize = analyserFftSize || 4096;
  analyser.smoothingTimeConstant = 0.15;
  src = audioCtx.createBufferSource(); src.buffer = buffer; src.loop = true;
  src.connect(distortion); distortion.connect(filter); filter.connect(masterGain); masterGain.connect(analyser); masterGain.connect(audioCtx.destination);

  // modal visual branch
  buildModalBank();
  // connect src to every modal filter input
  for(let i=0;i<PARTIALS;i++){
    src.connect(modalFilters[i]);
  }
  src.start();
  rod.classList.add('playing');
}

/* disconnect everything */
function stopPlayback(){
  if(src){ try{ src.stop(0); }catch{} try{ src.disconnect(); }catch{} }
  src = null;
  [distortion, filter, masterGain, analyser, preAnalyser, preSum].forEach(n=>{ if(n){ try{ n.disconnect(); }catch{} }});
  modalFilters=[]; modalGains=[]; preAnalyser=null; preSum=null;
  glitching=false; rod.classList.remove('playing'); rod.classList.remove('glitch');
}

/* mapping gestures -> modal excitation */
function mapParams(v,a,p){
  const vn=Math.min(1,Math.abs(v)/MAX_VELOCITY);
  const an=Math.min(1,Math.abs(a)/MAX_ACCEL);
  const baseExcite = Math.max(0, 1 - an*1.2); // steady gestures favor low modes
  const exciteHigh = Math.min(1, an*1.5 + vn*0.6); // rough gestures excite high modes
  const loud = 0.2 + Math.min(1, p*PRESSURE_SENSITIVITY); // pressure contributes to overall energy
  return {baseExcite,exciteHigh,loud,an,vn};
}

function applyModalGains(params){
  if(!modalGains || modalGains.length===0) return;
  // for each partial, compute a desired gain value and smooth it
  for(let i=0;i<PARTIALS;i++){
    // weight from 0..1; lower modes get weight from baseExcite, higher modes from exciteHigh
    const idx = i+1;
    const highFactor = idx / PARTIALS; // 0..1
    // modal balance
    const target = params.loud * ( (1 - highFactor) * params.baseExcite * 0.9 + highFactor * params.exciteHigh * 1.6 ) / idx;
    // small transient boost if user just hit (we handle onDown)
    try{
      modalGains[i].gain.setTargetAtTime(target, audioCtx.currentTime, 0.04);
    }catch(e){
      modalGains[i].gain.value = target;
    }
  }
}

/* strike/transient to make touchstart realistic */
function transientStrike(strength=1.0){
  if(!modalGains) return;
  const t = audioCtx.currentTime;
  for(let i=0;i<PARTIALS;i++){
    const idx = i+1;
    const highFactor = idx / PARTIALS;
    const burst = 0.8 * (1 - highFactor*0.6) * strength / idx;
    // quick ramp up then back to mapped level
    try{
      modalGains[i].gain.cancelScheduledValues(t);
      modalGains[i].gain.setValueAtTime(Math.min(0.0001, modalGains[i].gain.value||0), t);
      modalGains[i].gain.linearRampToValueAtTime(burst, t + 0.012);
      modalGains[i].gain.linearRampToValueAtTime((modalGains[i].gain.value||0), t + 0.12);
    }catch(e){
      modalGains[i].gain.value = burst;
    }
  }
}

/* gesture handlers */
function onDown(e){
  e.preventDefault();
  ensureAudioCtx();
  if(audioCtx.state==='suspended') audioCtx.resume();
  if(!buffer){ instr.textContent = 'Please upload a WAV first.'; return; }
  active=true;
  const t = e.touches ? e.touches[0] : e;
  lastY = t.clientY; lastVelocity = 0; pressure = t.force || 0.5;
  startPlayback();
  // initial transient to simulate strike on contact
  transientStrike(Math.min(1.8, 0.6 + (pressure||0)));
}
function onMove(e){
  if(!active) return;
  const t = e.touches ? e.touches[0] : e;
  const y = t.clientY, f = t.force || 0.5;
  velocity = y - lastY;
  acceleration = velocity - lastVelocity;
  pressure = f;
  const p = mapParams(velocity, acceleration, pressure);

  // apply to actual sound timbre (unchanged chain as before)
  if(filter) filter.frequency.setTargetAtTime(2000 + p.vn*9000, audioCtx.currentTime, 0.05);
  if(distortion) distortion.curve = makeDistortion(Math.min(0.9, p.exc || 0)).curve;
  if(masterGain) masterGain.gain.setTargetAtTime(0.35 + Math.min(1, pressure*PRESSURE_SENSITIVITY), audioCtx.currentTime, 0.03);

  // mirror computed parameters to modal bank (visual branch)
  applyModalGains(p);

  // visual feedback
  if(Math.abs(acceleration) > 10) spawnParticles(y, acceleration, pressure);
  if((p.an>0.6) && !glitching){ glitching = true; rod.classList.add('glitch'); }
  else if((p.an<0.3) && glitching){ glitching = false; rod.classList.remove('glitch'); }

  lastVelocity = velocity; lastY = y;
}
function onUp(){
  if(active){ active=false; stopPlayback(); }
}

/* drag + file */
fileInput.addEventListener('change', async ev => { if(ev.target.files && ev.target.files[0]) await loadFile(ev.target.files[0]); });
rod.addEventListener('dragover', e=>{ e.preventDefault(); rod.style.opacity=0.9; });
rod.addEventListener('dragleave', ()=>rod.style.opacity='');
rod.addEventListener('drop', async e=>{ e.preventDefault(); rod.style.opacity=''; const f = e.dataTransfer.files[0]; if(f) await loadFile(f); });

/* main loop: draw particles + spectrogram from modal preAnalyser */
function animate(t){
  const dt = (t - lastT) / 1000; lastT = t;
  updateParticles(dt); drawParticles();

  if(preAnalyser && audioCtx){
    const freqData = new Uint8Array(preAnalyser.frequencyBinCount);
    preAnalyser.getByteFrequencyData(freqData);
    drawSpectrogram(freqData);
  } else if(analyser && audioCtx){
    const freqData = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(freqData);
    drawSpectrogram(freqData);
  }

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* listeners */
rod.addEventListener('touchstart', onDown, {passive:false});
window.addEventListener('touchmove', onMove, {passive:false});
window.addEventListener('touchend', onUp, {passive:false});
window.addEventListener('touchcancel', onUp, {passive:false});
rod.addEventListener('pointerdown', onDown);
window.addEventListener('pointermove', onMove);
window.addEventListener('pointerup', onUp);
document.addEventListener('visibilitychange', ()=>{ if(document.hidden && active) onUp(); });
</script>
</body>
</html>