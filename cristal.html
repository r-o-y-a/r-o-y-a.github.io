<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Cristal — synth default (upload overrides) — fixed touch</title>
<style>
  :root{--bg:#0b0b0c;--rod-glow:#9fe1ff;--text:#e6eef6}
  /* Disable selection/drag/callout */
  html,body,*{user-select:none;-webkit-user-select:none;-webkit-touch-callout:none;-webkit-user-drag:none;touch-action:none}
  html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,-apple-system,Segoe UI,Roboto}
  .instructions{position:fixed;top:6px;left:6px;right:6px;z-index:50;color:var(--text);font-size:14px;text-align:center;pointer-events:none}
  #uploadBtn{position:fixed;top:6px;right:6px;z-index:60;pointer-events:auto}
  #fileLabel{font-size:12px;color:#cfe9ff;margin-top:6px}
  input[type=file]{display:none}
  .stage{box-sizing:border-box;width:100%;height:100%;display:flex;align-items:center;justify-content:center;position:relative}
  .rod{
    width:8mm;height:100vh;max-height:100vh;border-radius:6px;
    background:linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
    box-shadow:0 8px 30px rgba(0,0,0,0.6), inset 0 0 18px rgba(255,255,255,0.02);
    display:flex;align-items:center;justify-content:center;transition:box-shadow 120ms, transform 120ms;
    -webkit-tap-highlight-color: transparent;pointer-events:auto;touch-action:none;
  }
  .rod.playing{box-shadow:0 10px 40px rgba(0,0,0,0.7),0 0 28px var(--rod-glow),inset 0 0 22px rgba(255,255,255,0.05);transform:scale(1.01)}
  .rod.glitch{box-shadow:0 10px 40px rgba(0,0,0,0.7),0 0 40px #ff9fa0,inset 0 0 22px rgba(255,255,255,0.05);transform:scale(1.03) rotate(-0.2deg)}
  .hairline{width:60%;height:2px;background:linear-gradient(90deg,transparent,rgba(255,255,255,0.12),transparent);border-radius:2px;opacity:0.9}
  button{pointer-events:auto}
</style>
</head>
<body>
  <div class="instructions" id="instr">Default synth (A≈220.25Hz). Upload WAV (top-right) to override. Touch rod to play; wiggle to glitch.</div>

  <div id="uploadBtn">
    <label style="display:inline-block">
      <button id="btn">Upload WAV</button>
      <input id="fileInput" type="file" accept=".wav,audio/*">
    </label>
    <div id="fileLabel"></div>
  </div>

  <div class="stage">
    <div id="rod" class="rod" role="button" aria-label="Glass rod">
      <div class="hairline"></div>
    </div>
  </div>

<script>
/* ======= CONFIG ======= */
const SMOOTH_ALPHA = 0.18, DEV_THRESHOLD_PX = 8, DEV_PERSIST = 3, MAX_DEV_FOR_RATE = 80,
      STUTTER_RATE_MIN = 6, STUTTER_RATE_MAX = 22, STUTTER_DUTY = 0.5;
const DEFAULT_FREQ = 220.25; // A3 from your cristal tuning
/* ====================== */

let audioCtx = null;
let buffer = null;          // uploaded WAV
let usingSynth = true;

let src = null;             // BufferSource if playing WAV
let osc1 = null, osc2 = null, synthGain = null; // synth nodes

let distortion = null, filter = null, chopGain = null, masterGain = null;
let stutterTimer = null;

let active = false, trendY = null, devCounter = 0, glitching = false, lastY = null;

const rod = document.getElementById('rod');
const fileInput = document.getElementById('fileInput');
const fileLabel = document.getElementById('fileLabel');
const instr = document.getElementById('instr');

function ensureAudioCtx(){ if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

function makeDistortion(amount=0){
  const ws = audioCtx.createWaveShaper();
  const k = Math.max(0, Math.min(1000, amount * 400));
  const n=2048; const curve=new Float32Array(n);
  for(let i=0;i<n;i++){const x=(i/(n-1))*2-1; curve[i]=(1+k)*x/(1+k*Math.abs(x));}
  ws.curve = curve; ws.oversample='2x'; return ws;
}

function startPlayback(){
  if (!audioCtx) return;
  // create common chain
  distortion = makeDistortion(0.0);
  filter = audioCtx.createBiquadFilter(); filter.type='lowpass'; filter.frequency.value=12000; filter.Q.value=0.7;
  chopGain = audioCtx.createGain(); chopGain.gain.value = 1;
  masterGain = audioCtx.createGain(); masterGain.gain.value = 0.95;
  // connect common chain
  distortion.connect(filter);
  filter.connect(chopGain);
  chopGain.connect(masterGain);
  masterGain.connect(audioCtx.destination);

  if (!usingSynth && buffer){
    // play uploaded WAV
    src = audioCtx.createBufferSource();
    src.buffer = buffer;
    src.loop = true;
    src.connect(distortion);
    src.start();
  } else {
    // start synth
    osc1 = audioCtx.createOscillator();
    osc2 = audioCtx.createOscillator();
    osc1.type = 'sine'; osc2.type = 'sine';
    osc1.frequency.value = DEFAULT_FREQ;
    osc2.frequency.value = DEFAULT_FREQ * 2;
    osc2.detune.value = -6;
    synthGain = audioCtx.createGain(); synthGain.gain.value = 0.6;
    osc1.connect(synthGain); osc2.connect(synthGain);
    synthGain.connect(distortion);
    osc1.start(); osc2.start();
  }
  rod.classList.add('playing');
}

function stopPlayback(){
  try{ if (src){ src.stop(0); src.disconnect(); } }catch(e){}
  src = null;
  try{ if (osc1){ osc1.stop(0); osc1.disconnect(); } }catch(e){}
  try{ if (osc2){ osc2.stop(0); osc2.disconnect(); } }catch(e){}
  osc1 = null; osc2 = null;
  try{ if (synthGain) synthGain.disconnect(); }catch(e){} synthGain = null;

  clearStutter();
  // disconnect common chain
  try{ if (distortion) distortion.disconnect(); }catch(e){} distortion = null;
  try{ if (filter) filter.disconnect(); }catch(e){} filter = null;
  try{ if (chopGain) chopGain.disconnect(); }catch(e){} chopGain = null;
  try{ if (masterGain) masterGain.disconnect(); }catch(e){} masterGain = null;

  glitching = false; devCounter = 0; lastY = null; trendY = null;
  rod.classList.remove('playing'); rod.classList.remove('glitch');
}

function engageGlitch(rateHz, strength){
  if (glitching) return;
  glitching = true;
  rod.classList.add('glitch');
  if (distortion) distortion.curve = makeDistortion(strength).curve;
  if (filter) filter.frequency.setTargetAtTime(4000 + (1-strength)*8000, audioCtx.currentTime, 0.04);
  startStutter(rateHz);
}

function clearGlitch(){
  if (!glitching) return;
  glitching = false;
  rod.classList.remove('glitch');
  if (distortion) distortion.curve = makeDistortion(0).curve;
  if (filter) filter.frequency.setTargetAtTime(12000, audioCtx.currentTime, 0.06);
  clearStutter();
}

function startStutter(rateHz){
  clearStutter();
  if (!chopGain) return;
  const periodMs = 1000 / rateHz;
  let on = true;
  chopGain.gain.setValueAtTime(1, audioCtx.currentTime);
  stutterTimer = setInterval(()=>{
    on = !on;
    try{ chopGain.gain.setValueAtTime(on ? 1 : 0, audioCtx.currentTime); }catch(e){}
  }, periodMs * STUTTER_DUTY);
}

function clearStutter(){
  if (stutterTimer){ clearInterval(stutterTimer); stutterTimer = null; }
  if (chopGain) try{ chopGain.gain.setValueAtTime(1, audioCtx.currentTime); }catch(e){}
}

function mapDevToParams(absDev){
  const d = Math.min(MAX_DEV_FOR_RATE, absDev);
  const t = d / MAX_DEV_FOR_RATE;
  const rate = STUTTER_RATE_MIN + t * (STUTTER_RATE_MAX - STUTTER_RATE_MIN);
  return { rateHz: rate, strength: t };
}

/* --------- POINTER / TOUCH HANDLERS (robust) --------- */
function normalizedPrevent(e){
  try{ if (e && typeof e.preventDefault === 'function') e.preventDefault(); }catch(e){}
}

function onPointerDown(e){
  normalizedPrevent(e);
  ensureAudioCtx();
  try{ if (audioCtx.state === 'suspended') audioCtx.resume(); }catch(e){}
  usingSynth = !buffer;
  if (!usingSynth && !buffer){
    instr.textContent = 'Upload WAV or use synth default.';
    return;
  }
  active = true;
  const y = (e && (e.clientY !== undefined)) ? e.clientY : (e && e.touches && e.touches[0] && e.touches[0].clientY);
  trendY = y; lastY = y; devCounter = 0; glitching = false;
  startPlayback();
  if (e && e.pointerId && rod.setPointerCapture){
    try{ rod.setPointerCapture(e.pointerId); }catch(o){}
  }
}

function onPointerMove(e){
  if (!active) return;
  const y = (e && (e.clientY !== undefined)) ? e.clientY : (e && e.touches && e.touches[0] && e.touches[0].clientY);
  if (y == null) return;
  trendY += SMOOTH_ALPHA * (y - trendY);
  const deviation = y - trendY, absDev = Math.abs(deviation);
  if (absDev > DEV_THRESHOLD_PX) devCounter = Math.min(DEV_PERSIST + 10, devCounter + 1);
  else devCounter = Math.max(0, devCounter - 1);

  if (devCounter >= DEV_PERSIST && !glitching){
    const p = mapDevToParams(absDev); engageGlitch(p.rateHz, p.strength);
  } else if (glitching && devCounter < 1){
    clearGlitch();
  } else if (glitching){
    const p = mapDevToParams(absDev);
    if (stutterTimer) startStutter(p.rateHz);
    if (distortion) distortion.curve = makeDistortion(p.strength).curve;
    if (filter) filter.frequency.setTargetAtTime(4000 + (1-p.strength)*8000, audioCtx.currentTime, 0.03);
  }
  lastY = y;
}

function onPointerUp(e){
  normalizedPrevent(e);
  active = false;
  stopPlayback();
  if (e && e.pointerId && rod.releasePointerCapture){
    try{ rod.releasePointerCapture(e.pointerId); }catch(o){}
  }
}

/* ---------- Touch wrappers (fixes mobile issues) ---------- */
/* These call preventDefault on the real TouchEvent and pass a small object
   into the existing handlers so the handlers don't break. */
rod.addEventListener('touchstart', (ev) => {
  ev.preventDefault();
  const t = ev.changedTouches[0];
  onPointerDown({
    clientY: t ? t.clientY : undefined,
    pointerId: undefined,
    preventDefault: ()=>{}
  });
}, { passive:false });

window.addEventListener('touchmove', (ev) => {
  ev.preventDefault();
  const t = ev.touches[0];
  onPointerMove({
    clientY: t ? t.clientY : undefined
  });
}, { passive:false });

window.addEventListener('touchend', (ev) => {
  ev.preventDefault();
  onPointerUp({ pointerId: undefined });
}, { passive:false });

window.addEventListener('touchcancel', (ev) => {
  ev.preventDefault();
  onPointerUp({});
}, { passive:false });

/* ---------- Pointer & mouse events ---------- */
rod.addEventListener('pointerdown', onPointerDown);
window.addEventListener('pointermove', onPointerMove);
window.addEventListener('pointerup', onPointerUp);

/* ---------- File upload / drag-drop ---------- */
fileInput.addEventListener('change', async (ev)=>{
  if (!ev.target.files || !ev.target.files[0]) return;
  await loadFile(ev.target.files[0]);
});

async function loadFile(file){
  ensureAudioCtx();
  try{
    const ab = await file.arrayBuffer();
    buffer = await audioCtx.decodeAudioData(ab);
    fileLabel.textContent = file.name;
    usingSynth = !buffer;
    instr.textContent = 'Uploaded: ' + file.name;
  }catch(err){
    console.warn('Failed to load file:', err);
    instr.textContent = 'Error decoding WAV — try another file.';
    buffer = null;
    usingSynth = true;
  }
}

rod.addEventListener('dragover', (e)=>{ e.preventDefault(); rod.style.opacity = 0.9; });
rod.addEventListener('dragleave', ()=>{ rod.style.opacity = ''; });
rod.addEventListener('drop', async (e)=>{ e.preventDefault(); rod.style.opacity = ''; const f = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0]; if (f) await loadFile(f); });

/* ---------- UI helpers ---------- */
document.getElementById('btn').addEventListener('click', ()=>fileInput.click());
document.addEventListener('visibilitychange', ()=>{ if (document.hidden && active) onPointerUp({}); });
</script>
</body>
</html>
